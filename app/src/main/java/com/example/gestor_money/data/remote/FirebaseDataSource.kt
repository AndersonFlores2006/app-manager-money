package com.example.gestor_money.data.remote

import android.util.Log
import com.example.gestor_money.data.local.entities.BudgetEntity
import com.example.gestor_money.data.local.entities.CategoryEntity
import com.example.gestor_money.data.local.entities.TransactionEntity
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Implementaci√≥n de RemoteDataSource usando Firebase Firestore
 */
@Singleton
class FirebaseDataSource @Inject constructor(
    private val firestore: FirebaseFirestore
) : RemoteDataSource {

    companion object {
        private const val TAG = "FirebaseDataSource"
        private const val COLLECTION_TRANSACTIONS = "transactions"
        private const val COLLECTION_CATEGORIES = "categories"
        private const val COLLECTION_BUDGETS = "budgets"
    }

    // ======================== TRANSACTIONS ========================

    override suspend fun uploadTransaction(userId: String, transaction: TransactionEntity): Result<String> {
        return try {
            val data = hashMapOf(
                "userId" to userId,
                "amount" to transaction.amount,
                "date" to transaction.date,
                "description" to transaction.description,
                "categoryId" to transaction.categoryId,
                "type" to transaction.type,
                "lastModified" to transaction.lastModified
            )

            val docRef = firestore.collection(COLLECTION_TRANSACTIONS).add(data).await()
            Log.d(TAG, "Transaction uploaded with ID: ${docRef.id}")
            Result.success(docRef.id)
        } catch (e: Exception) {
            Log.e(TAG, "Error uploading transaction", e)
            Result.failure(e)
        }
    }

    override suspend fun updateTransaction(userId: String, transaction: TransactionEntity): Result<Unit> {
        return try {
            val cloudId = transaction.cloudId ?: return Result.failure(Exception("CloudId is null"))

            val data = hashMapOf(
                "userId" to userId,
                "amount" to transaction.amount,
                "date" to transaction.date,
                "description" to transaction.description,
                "categoryId" to transaction.categoryId,
                "type" to transaction.type,
                "lastModified" to transaction.lastModified
            )

            firestore.collection(COLLECTION_TRANSACTIONS).document(cloudId).set(data).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Error updating transaction", e)
            Result.failure(e)
        }
    }

    override suspend fun deleteTransaction(userId: String, cloudId: String): Result<Unit> {
        return try {
            // Note: userId is passed to align with the interface, useful for security rules
            firestore.collection(COLLECTION_TRANSACTIONS).document(cloudId).delete().await()
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Error deleting transaction", e)
            Result.failure(e)
        }
    }

    override suspend fun getAllTransactions(userId: String): Result<List<TransactionEntity>> {
        return try {
            val snapshot = firestore.collection(COLLECTION_TRANSACTIONS)
                .whereEqualTo("userId", userId)
                .get()
                .await()

            val transactions = snapshot.documents.mapNotNull { doc ->
                try {
                    TransactionEntity(
                        id = 0, // Will be auto-generated by Room
                        cloudId = doc.id,
                        syncStatus = "SYNCED",
                        lastModified = doc.getLong("lastModified") ?: System.currentTimeMillis(),
                        userId = userId,
                        amount = doc.getDouble("amount") ?: 0.0,
                        date = doc.getLong("date") ?: 0L,
                        description = doc.getString("description") ?: "",
                        categoryId = doc.getLong("categoryId"),
                        type = doc.getString("type") ?: "EXPENSE"
                    )
                } catch (e: Exception) {
                    Log.e(TAG, "Error parsing transaction ${doc.id}", e)
                    null
                }
            }

            Result.success(transactions)
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching transactions", e)
            Result.failure(e)
        }
    }

    // ======================== CATEGORIES ========================

    override suspend fun uploadCategory(userId: String, category: CategoryEntity): Result<String> {
        return try {
            val data = hashMapOf(
                "userId" to userId,
                "name" to category.name,
                "icon" to category.icon,
                "color" to category.color,
                "type" to category.type,
                "lastModified" to category.lastModified
            )

            val docRef = firestore.collection(COLLECTION_CATEGORIES).add(data).await()
            Log.d(TAG, "Category uploaded with ID: ${docRef.id}")
            Result.success(docRef.id)
        } catch (e: Exception) {
            Log.e(TAG, "Error uploading category", e)
            Result.failure(e)
        }
    }

    override suspend fun updateCategory(userId: String, category: CategoryEntity): Result<Unit> {
        return try {
            val cloudId = category.cloudId ?: return Result.failure(Exception("CloudId is null"))

            val data = hashMapOf(
                "userId" to userId,
                "name" to category.name,
                "icon" to category.icon,
                "color" to category.color,
                "type" to category.type,
                "lastModified" to category.lastModified
            )

            firestore.collection(COLLECTION_CATEGORIES).document(cloudId).set(data).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Error updating category", e)
            Result.failure(e)
        }
    }

    override suspend fun deleteCategory(userId: String, cloudId: String): Result<Unit> {
        return try {
            firestore.collection(COLLECTION_CATEGORIES).document(cloudId).delete().await()
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Error deleting category", e)
            Result.failure(e)
        }
    }

    override suspend fun getAllCategories(userId: String): Result<List<CategoryEntity>> {
        return try {
            val snapshot = firestore.collection(COLLECTION_CATEGORIES)
                .whereEqualTo("userId", userId)
                .get()
                .await()

            val categories = snapshot.documents.mapNotNull { doc ->
                try {
                    CategoryEntity(
                        id = 0,
                        cloudId = doc.id,
                        syncStatus = "SYNCED",
                        lastModified = doc.getLong("lastModified") ?: System.currentTimeMillis(),
                        userId = userId,
                        name = doc.getString("name") ?: "",
                        icon = doc.getString("icon") ?: "",
                        color = doc.getLong("color")?.toInt() ?: 0,
                        type = doc.getString("type") ?: "EXPENSE"
                    )
                } catch (e: Exception) {
                    Log.e(TAG, "Error parsing category ${doc.id}", e)
                    null
                }
            }

            Result.success(categories)
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching categories", e)
            Result.failure(e)
        }
    }

    // ======================== BUDGETS ========================

    override suspend fun uploadBudget(userId: String, budget: BudgetEntity): Result<String> {
        return try {
            val data = hashMapOf(
                "userId" to userId,
                "categoryId" to budget.categoryId,
                "amount" to budget.amount,
                "month" to budget.month,
                "year" to budget.year,
                "lastModified" to budget.lastModified
            )

            val docRef = firestore.collection(COLLECTION_BUDGETS).add(data).await()
            Log.d(TAG, "Budget uploaded with ID: ${docRef.id}")
            Result.success(docRef.id)
        } catch (e: Exception) {
            Log.e(TAG, "Error uploading budget", e)
            Result.failure(e)
        }
    }

    override suspend fun updateBudget(userId: String, budget: BudgetEntity): Result<Unit> {
        return try {
            val cloudId = budget.cloudId ?: return Result.failure(Exception("CloudId is null"))

            val data = hashMapOf(
                "userId" to userId,
                "categoryId" to budget.categoryId,
                "amount" to budget.amount,
                "month" to budget.month,
                "year" to budget.year,
                "lastModified" to budget.lastModified
            )

            firestore.collection(COLLECTION_BUDGETS).document(cloudId).set(data).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Error updating budget", e)
            Result.failure(e)
        }
    }

    override suspend fun deleteBudget(userId: String, cloudId: String): Result<Unit> {
        return try {
            firestore.collection(COLLECTION_BUDGETS).document(cloudId).delete().await()
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Error deleting budget", e)
            Result.failure(e)
        }
    }

    override suspend fun getAllBudgets(userId: String): Result<List<BudgetEntity>> {
        return try {
            val snapshot = firestore.collection(COLLECTION_BUDGETS)
                .whereEqualTo("userId", userId)
                .get()
                .await()

            val budgets = snapshot.documents.mapNotNull { doc ->
                try {
                    BudgetEntity(
                        id = 0,
                        cloudId = doc.id,
                        syncStatus = "SYNCED",
                        lastModified = doc.getLong("lastModified") ?: System.currentTimeMillis(),
                        userId = userId,
                        categoryId = doc.getLong("categoryId") ?: 0L,
                        amount = doc.getDouble("amount") ?: 0.0,
                        month = doc.getLong("month")?.toInt() ?: 0,
                        year = doc.getLong("year")?.toInt() ?: 0
                    )
                } catch (e: Exception) {
                    Log.e(TAG, "Error parsing budget ${doc.id}", e)
                    null
                }
            }

            Result.success(budgets)
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching budgets", e)
            Result.failure(e)
        }
    }
}
